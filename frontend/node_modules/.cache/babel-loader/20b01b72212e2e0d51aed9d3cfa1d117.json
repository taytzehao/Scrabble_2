{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\TzeHaoTay\\\\Desktop\\\\CS\\\\scrabble2\\\\frontend\\\\src\\\\Games_page\\\\Action\\\\Score_button.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useContext, useEffect, useRef } from 'react';\nimport { UserContext, SocketContext } from '../../UserContext.js';\nimport { GamesContext, BlocksContext, PlayerListContext, AnalyticsDataContext, SachetContext } from '../GamesContext.js';\nimport sachet, { analytics_data } from '../Sachet.js';\nimport { games_sachet } from '../Gamespage.js';\nimport './Actionbar.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Score_button(values) {\n  _s();\n\n  const {\n    profile,\n    setprofile\n  } = useContext(UserContext);\n  const {\n    playerlistState,\n    setplayerlistState\n  } = useContext(PlayerListContext);\n  const {\n    gameState,\n    setgameState\n  } = useContext(GamesContext);\n  const {\n    boardState,\n    setboardState\n  } = useContext(BlocksContext);\n  const {\n    analyticsdataState,\n    setanalyticsdataState\n  } = useContext(AnalyticsDataContext);\n  const {\n    sachetState,\n    setsachetState\n  } = useContext(SachetContext);\n  const websocket = useContext(SocketContext);\n  const playerlistRef = useRef(null);\n  const gamestateRef = useRef(null);\n  const boardstateRef = useRef(null);\n  const sachetstateRef = useRef(null);\n  playerlistRef.current = playerlistState;\n  gamestateRef.current = gameState;\n  boardstateRef.current = boardState;\n  sachetstateRef.current = sachetState;\n  const [scoreActive, setscoreActive] = useState(false);\n  const scorestyle = {\n    opacity: scoreActive ? 1 : 0.5\n  };\n  useEffect(() => {\n    if (gameState.player_turn == gameState.your_index && !playerlistState[gameState.your_index].delete_list.length && gamestateRef.just) {\n      setscoreActive(true);\n    } else {\n      setscoreActive(false);\n    }\n  }, [, gameState]);\n\n  function fail_return(player_turn) {\n    let return_tiles = [];\n\n    for (let i = 0; i < gamestateRef.current.just_added.length; i++) {\n      return_tiles.push(boardstateRef.current.blocks[gamestateRef.current.just_added[i]].content);\n      return_tiles[i].just_added = false;\n      return_tiles[i].placed = false;\n      return_tiles[i].canDrop = true;\n      return_tiles[i].container_index = playerlistRef.current[player_turn].tiles.length + i;\n    }\n\n    websocket.current.emit(\"emit_fail_return\", {\n      return_tiles: return_tiles,\n      room_id: gamestateRef.current.room_id,\n      just_added: gamestateRef.current.just_added,\n      player_turn: gamestateRef.current.player_turn\n    });\n    values.fail_return_funct(gamestateRef.current.player_turn, return_tiles, gamestateRef.current.just_added);\n  }\n\n  function tile_coordinate(index) {\n    let row = Math.floor(index / boardstateRef.current.column_length);\n    let column = index % boardstateRef.current.column_length;\n    return [row, column];\n  }\n\n  function tile_index(coordinate) {\n    return coordinate[0] * boardstateRef.current.column_length + coordinate[1];\n  }\n\n  function check_board(coordinate) {\n    if (coordinate[0] < 0 || coordinate[0] >= boardstateRef.current.row_length || coordinate[1] < 0 || coordinate[1] >= boardstateRef.current.column_length) {\n      return false;\n    }\n\n    let index = tile_index(coordinate);\n\n    if (boardstateRef.current.blocks[index].content) {\n      if (boardstateRef.current.blocks[index].content.placed) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function check_validity() {\n    if (gamestateRef.current.turn_num == 0) {\n      let start_block = boardstateRef.current.blocks.find(block => block.type == \"st\");\n\n      if (!start_block.content) {\n        alert(\"Please place the tile on the start block.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n    } else {\n      let attached = false;\n\n      for (let i = 0; i < gamestateRef.current.just_added.length; i++) {\n        let coor = tile_coordinate(gamestateRef.current.just_added[i]);\n        let up, down, left, right;\n        up = down = left = right = coor;\n        up[0] = up[0] - 1;\n        down[0] = down[0] + 1;\n        left[1] = left[1] - 1;\n        right[1] = right[1] + 1;\n\n        if (check_board(up) || check_board(down) || check_board(left) || check_board(right)) {\n          attached = true;\n          break;\n        }\n      }\n\n      if (attached == false) {\n        alert(\"Please place your tiles adjacent to an existing tile.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n    }\n\n    if (gamestateRef.current.just_added.length > 1) {\n      let first_coordinate = tile_coordinate(gamestateRef.current.just_added[0]);\n      let second_coordinate = tile_coordinate(gamestateRef.current.just_added[1]);\n\n      if (first_coordinate[0] == second_coordinate[0]) {\n        var direction = \"horizontal\";\n      } else if (first_coordinate[1] == second_coordinate[1]) {\n        var direction = \"vertical\";\n      } else {\n        alert(\"Your sequence of tiles must either be in horizontal or vertical form, adjacent to each other.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n\n      for (let i = 1; i < gamestateRef.current.just_added; i++) {\n        if (direction == \"horizontal\") {\n          if (first_coordinate[1] + 1 != second_coordinate[1] && first_coordinate[0] == second_coordinate[0]) {\n            let temp_second_coord = first_coordinate;\n            temp_second_coord[1] = temp_second_coord[1] + 1;\n\n            while (temp_second_coord[1] <= second_coordinate[1]) {\n              if (!check_board(temp_second_coord)) {\n                alert(\"Please do not skip\");\n                fail_return(gamestateRef.current.player_turn);\n                return false;\n              }\n\n              temp_second_coord[1] = temp_second_coord[1] + 1;\n            }\n          } else if (first_coordinate[0] != second_coordinate[0]) {\n            alert(\"Please place all in horizontal\");\n            fail_return(gamestateRef.current.player_turn);\n            return false;\n          }\n        } else if (direction == \"vertical\") {\n          if (first_coordinate[0] + 1 != second_coordinate[0] && first_coordinate[1] == second_coordinate[1]) {\n            let temp_second_coord = first_coordinate;\n            temp_second_coord[0] = temp_second_coord[0] + 1;\n\n            while (temp_second_coord[0] <= second_coordinate[0]) {\n              if (!check_board(temp_second_coord)) {\n                alert(\"Please do not skip\");\n                fail_return(gamestateRef.current.player_turn);\n                return false;\n              }\n\n              temp_second_coord[0] = temp_second_coord[0] + 1;\n            }\n          }\n        } else if (first_coordinate[1] != second_coordinate[1]) {\n          alert(\"Please place all in vertical\");\n          fail_return(gamestateRef.current.player_turn);\n          return false;\n        }\n\n        first_coordinate = second_coordinate;\n\n        if (i + 1 != gamestateRef.current.just_added.length) {\n          second_coordinate = tile_coordinate(gamestateRef.current.just_added[i + 1]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function vertical_words(new_tile, up, down) {\n    let vertical_word_tile = [];\n    let prepend_up = false;\n\n    if (check_board(up)) {\n      prepend_up = true;\n      vertical_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n\n      while (check_board(up)) {\n        vertical_word_tile[vertical_word_tile.length - 1].unshift(boardstateRef.current.blocks[tile_index(up)]);\n        up[0] = up[0] - 1;\n      }\n    }\n\n    if (check_board(down)) {\n      if (prepend_up == false) {\n        vertical_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n      }\n\n      while (check_board(down)) {\n        vertical_word_tile[vertical_word_tile.length - 1].push(boardstateRef.current.blocks[tile_index(down)]);\n        down[0] = down[0] + 1;\n      }\n    }\n\n    return vertical_word_tile;\n  }\n\n  function horizontal_words(new_tile, left, right) {\n    let horizontal_word_tile = [];\n    let prepend_left = false;\n\n    if (check_board(left)) {\n      prepend_left = true;\n      horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n\n      while (check_board(left)) {\n        horizontal_word_tile[horizontal_word_tile.length - 1].unshift(boardstateRef.current.blocks[tile_index(left)]);\n        left[1] = left[1] - 1;\n      }\n    }\n\n    if (check_board(right)) {\n      if (prepend_left == false) {\n        horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n      }\n\n      while (check_board(right)) {\n        horizontal_word_tile[horizontal_word_tile.length - 1].push(boardstateRef.current.blocks[tile_index(right)]);\n        right[1] = right[1] + 1;\n      }\n    }\n\n    return horizontal_word_tile;\n  }\n\n  function set_words_block(new_tiles) {\n    let words = [];\n    let coor = tile_coordinate(gamestateRef.current.just_added[0]);\n    let up, down, left, right;\n    up = coor.slice(0);\n    down = coor.slice(0);\n    left = coor.slice(0);\n    right = coor.slice(0);\n    up[0] = up[0] - 1;\n    down[0] = down[0] + 1;\n    left[1] = left[1] - 1;\n    right[1] = right[1] + 1;\n\n    if (new_tiles.length == 1) {\n      horizontal_words(gamestateRef.current.just_added[0], left, right).forEach(horizontal_word => words.push(horizontal_word));\n      vertical_words(gamestateRef.current.just_added[0], up, down).forEach(vertical_word => words.push(vertical_word));\n    } else {\n      if (tile_coordinate(gamestateRef.current.just_added[0])[0] == tile_coordinate(gamestateRef.current.just_added[1])[0]) {\n        //horizontal\n        horizontal_words(gamestateRef.current.just_added[0], left, right).forEach(horizontal_word => words.push(horizontal_word));\n\n        for (let i = 0; i < new_tiles.length; i++) {\n          vertical_words(new_tiles[i], up, down).forEach(vertical_word => words.push(vertical_word));\n        }\n      } else {\n        //vertical\n        vertical_words(new_tiles[0], up, down).forEach(vertical_word => words.push(vertical_word));\n\n        for (let i = 0; i < new_tiles.length; i++) {\n          horizontal_words(new_tiles[i], left, right).forEach(horizontal_word => words.push(horizontal_word));\n        }\n      }\n    }\n\n    return words;\n  }\n\n  function new_block_score(new_block) {\n    let new_block_s = 0;\n    let double_word = 0;\n    let triple_word = 0;\n\n    if (new_block.type == \"dw\" || new_block.type == \"st\") {\n      new_block_s += new_block.content.score;\n      double_word += 1;\n    } else if (new_block.type == \"tw\") {\n      new_block_s += new_block.content.score;\n      triple_word += 1;\n    } else if (new_block.type == \"dl\") {\n      new_block_s += new_block.content.score * 2;\n    } else if (new_block.type == \"tl\") {\n      new_block_s += new_block.content.score * 3;\n    } else {\n      new_block_s += new_block.content.score;\n    }\n\n    return [new_block_s, double_word, triple_word];\n  }\n\n  function old_block_score(old_block) {\n    let old_tile_s = 0;\n    old_tile_s += old_block.content.score;\n    return old_tile_s;\n  }\n\n  function word_score(word_blocks) {\n    let individual_word_score = 0;\n    var double_word = 0;\n    var triple_word = 0;\n\n    for (let z = 0; z < word_blocks.length; z++) {\n      if (word_blocks[z].content.just_added == true) {\n        let scores = new_block_score(word_blocks[z]);\n        individual_word_score += scores[0];\n        double_word += scores[1];\n        triple_word += scores[2];\n      } else {\n        individual_word_score += old_block_score(word_blocks[z]);\n      }\n    }\n\n    if (double_word != 0) {\n      individual_word_score = individual_word_score * 2 * double_word;\n    }\n\n    if (triple_word != 0) {\n      individual_word_score = individual_word_score * 3 * triple_word;\n    }\n\n    return individual_word_score;\n  }\n\n  function additionalscore(words) {\n    let extra_score = 0;\n\n    for (let y = 0; y < words.length; y++) {\n      extra_score += word_score(words[y]);\n    }\n\n    if (gamestateRef.current.just_added.length == 7) {\n      extra_score += 50;\n    }\n\n    return extra_score;\n  }\n\n  function Score() {\n    if (check_validity()) {\n      let words_block = set_words_block(gamestateRef.current.just_added);\n      let updated_score = playerlistRef.current[gamestateRef.current.player_turn].score + additionalscore(words_block);\n      let sachet = { ...sachetstateRef.current\n      };\n      Object.setPrototypeOf(sachet, sachetstateRef.current);\n      let drawn_tiles = playerlistRef.current[gamestateRef.current.player_turn].draw(sachet);\n      setplayerlistState(prevplayerlistState => {\n        let newplayerlistState = [...prevplayerlistState];\n        newplayerlistState[gamestateRef.current.player_turn].score = updated_score;\n        newplayerlistState[gamestateRef.current.player_turn].draw_by_tiles(drawn_tiles);\n        return newplayerlistState;\n      });\n      let words_alphabet = [];\n\n      for (let i = 0; i < words_block.length; i++) {\n        words_alphabet.push([\"\"]);\n\n        for (let y = 0; y < words_block[i].length; y++) {\n          words_alphabet[i] += words_block[i][y].content.alphabet;\n        }\n      }\n\n      values.next_funct(sachet, words_alphabet, gamestateRef.current.player_turn);\n\n      for (let i = 0; i < drawn_tiles.length; i++) {\n        drawn_tiles[i].canDrop = false;\n        drawn_tiles[i].canDrag = false;\n      }\n\n      websocket.current.emit(\"emit_updated_score\", {\n        room_id: gamestateRef.current.room_id,\n        player_turn: gamestateRef.current.player_turn,\n        score: updated_score,\n        challenge_words: words_alphabet,\n        challenge_index: gamestateRef.current.player_turn,\n        drawn_tiles: drawn_tiles\n      });\n    }\n  }\n\n  useEffect(() => {\n    websocket.current.on(\"update_player_score\", socket_out => {\n      let sachet2 = { ...sachetstateRef.current\n      };\n      Object.setPrototypeOf(sachet2, sachetstateRef.current);\n      sachet2.remove_by_tiles(socket_out.drawn_tiles);\n      let updated_container = playerlistRef.current[socket_out.player_turn].tiles.concat(socket_out.drawn_tiles);\n      setplayerlistState(prevplayerlistState => {\n        let newplayerlistState = [...prevplayerlistState];\n        newplayerlistState[socket_out.player_turn].score = socket_out.score;\n        newplayerlistState[socket_out.player_turn].tiles = updated_container;\n        return newplayerlistState;\n      });\n      values.next_funct(sachet2, socket_out.challenge_words, socket_out.challenge_index);\n    });\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"button\", {\n      type: \"button\",\n      className: \"score_button gamesbtn\",\n      style: scorestyle,\n      onClick: Score,\n      disabled: !scoreActive,\n      children: \"Score\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 393,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 392,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Score_button, \"nLhW5c2alX9EF3jcgPmZSFkckDg=\");\n\n_c = Score_button;\nexport default Score_button;\n\nvar _c;\n\n$RefreshReg$(_c, \"Score_button\");","map":{"version":3,"sources":["C:/Users/TzeHaoTay/Desktop/CS/scrabble2/frontend/src/Games_page/Action/Score_button.js"],"names":["React","useState","useContext","useEffect","useRef","UserContext","SocketContext","GamesContext","BlocksContext","PlayerListContext","AnalyticsDataContext","SachetContext","sachet","analytics_data","games_sachet","Score_button","values","profile","setprofile","playerlistState","setplayerlistState","gameState","setgameState","boardState","setboardState","analyticsdataState","setanalyticsdataState","sachetState","setsachetState","websocket","playerlistRef","gamestateRef","boardstateRef","sachetstateRef","current","scoreActive","setscoreActive","scorestyle","opacity","player_turn","your_index","delete_list","length","just","fail_return","return_tiles","i","just_added","push","blocks","content","placed","canDrop","container_index","tiles","emit","room_id","fail_return_funct","tile_coordinate","index","row","Math","floor","column_length","column","tile_index","coordinate","check_board","row_length","check_validity","turn_num","start_block","find","block","type","alert","attached","coor","up","down","left","right","first_coordinate","second_coordinate","direction","temp_second_coord","vertical_words","new_tile","vertical_word_tile","prepend_up","unshift","horizontal_words","horizontal_word_tile","prepend_left","set_words_block","new_tiles","words","slice","forEach","horizontal_word","vertical_word","new_block_score","new_block","new_block_s","double_word","triple_word","score","old_block_score","old_block","old_tile_s","word_score","word_blocks","individual_word_score","z","scores","additionalscore","extra_score","y","Score","words_block","updated_score","Object","setPrototypeOf","drawn_tiles","draw","prevplayerlistState","newplayerlistState","draw_by_tiles","words_alphabet","alphabet","next_funct","canDrag","challenge_words","challenge_index","on","socket_out","sachet2","remove_by_tiles","updated_container","concat"],"mappings":"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","sourcesContent":["import React, {useState,useContext,useEffect,useRef} from 'react';\r\nimport {UserContext,SocketContext} from '../../UserContext.js'\r\nimport {GamesContext,BlocksContext,PlayerListContext,AnalyticsDataContext,SachetContext} from '../GamesContext.js'\r\nimport sachet, { analytics_data } from '../Sachet.js';\r\nimport {games_sachet} from '../Gamespage.js'\r\nimport './Actionbar.css'\r\n\r\nfunction Score_button(values){\r\n  const {profile,setprofile}=useContext(UserContext)\r\n  const {playerlistState,setplayerlistState}=useContext(PlayerListContext)\r\n  const {gameState,setgameState}=useContext(GamesContext)   \r\n  const {boardState,setboardState}=useContext(BlocksContext)\r\n  const {analyticsdataState,setanalyticsdataState}=useContext(AnalyticsDataContext)\r\n  const {sachetState,setsachetState}=useContext(SachetContext)   \r\n  const websocket=useContext(SocketContext)\r\n  const playerlistRef=useRef(null);\r\n  const gamestateRef=useRef(null);\r\n  const boardstateRef=useRef(null);\r\n  const sachetstateRef=useRef(null);\r\n  playerlistRef.current=playerlistState\r\n  gamestateRef.current=gameState\r\n  boardstateRef.current=boardState\r\n  sachetstateRef.current=sachetState\r\n  const [scoreActive,setscoreActive]=useState(false)\r\n  const scorestyle={opacity:(scoreActive) ? 1 : 0.5}\r\n    useEffect(()=>{ \r\n        if(gameState.player_turn==gameState.your_index && !playerlistState[gameState.your_index].delete_list.length && gamestateRef.just){\r\n          setscoreActive(true)\r\n        }else{\r\n          setscoreActive(false)\r\n        }\r\n      },[,gameState])\r\n    \r\n    function fail_return(player_turn){\r\n      let return_tiles=[]\r\n      for (let i=0;i<gamestateRef.current.just_added.length;i++){\r\n        return_tiles.push(boardstateRef.current.blocks[gamestateRef.current.just_added[i]].content)\r\n        return_tiles[i].just_added=false\r\n        return_tiles[i].placed=false\r\n        return_tiles[i].canDrop=true\r\n        return_tiles[i].container_index=playerlistRef.current[player_turn].tiles.length+i\r\n      }\r\n      websocket.current.emit(\"emit_fail_return\",{\r\n        return_tiles:return_tiles,\r\n        room_id:gamestateRef.current.room_id,\r\n        just_added:gamestateRef.current.just_added,\r\n        player_turn:gamestateRef.current.player_turn\r\n      })\r\n      values.fail_return_funct(gamestateRef.current.player_turn,return_tiles,gamestateRef.current.just_added)\r\n      \r\n    }\r\n    function tile_coordinate(index){\r\n      let row = Math.floor(index / boardstateRef.current.column_length)\r\n      let column=index%boardstateRef.current.column_length\r\n      return [row,column]\r\n    }\r\n    function tile_index(coordinate){\r\n      return coordinate[0]*boardstateRef.current.column_length+coordinate[1];\r\n    }\r\n    function check_board(coordinate){\r\n      if (coordinate[0]<0 || coordinate[0]>=boardstateRef.current.row_length || coordinate[1]<0 || coordinate[1]>=boardstateRef.current.column_length){\r\n        return false\r\n    }\r\n      let index=tile_index(coordinate)\r\n      if(boardstateRef.current.blocks[index].content){\r\n        if(boardstateRef.current.blocks[index].content.placed){return true}\r\n      }\r\n      return false\r\n\r\n    }\r\n\r\n    function check_validity(){\r\n      if (gamestateRef.current.turn_num==0){\r\n        let start_block=boardstateRef.current.blocks.find(block=>block.type==\"st\")\r\n        if(!start_block.content){\r\n          alert(\"Please place the tile on the start block.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false\r\n        }\r\n      }else{\r\n        let attached=false;\r\n        for(let i=0;i<gamestateRef.current.just_added.length;i++){\r\n          let coor=tile_coordinate(gamestateRef.current.just_added[i])\r\n          let up,down,left,right;\r\n          up=down=left=right=coor;\r\n\r\n          up[0]=up[0]-1;\r\n          down[0]=down[0]+1;\r\n          left[1]=left[1]-1;\r\n          right[1]=right[1]+1;\r\n\r\n            if (check_board(up)||check_board(down)||check_board(left)||check_board(right)){\r\n                attached=true;\r\n                break;\r\n            }    \r\n        }\r\n        if (attached==false){\r\n          alert (\"Please place your tiles adjacent to an existing tile.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false;\r\n        }\r\n      }\r\n      if(gamestateRef.current.just_added.length>1){\r\n        let first_coordinate=tile_coordinate(gamestateRef.current.just_added[0]);\r\n        let second_coordinate=tile_coordinate(gamestateRef.current.just_added[1]);\r\n\r\n        if (first_coordinate[0]==second_coordinate[0] ){\r\n          var direction =\"horizontal\";\r\n      } else if (first_coordinate[1]==second_coordinate[1]){\r\n          var direction =\"vertical\";\r\n      } else {\r\n          alert (\"Your sequence of tiles must either be in horizontal or vertical form, adjacent to each other.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false;\r\n      }\r\n      for (let i =1 ; i<gamestateRef.current.just_added;i++){\r\n        if (direction==\"horizontal\"){\r\n             if ((first_coordinate[1]+1)!=second_coordinate[1] && first_coordinate[0]==second_coordinate[0]){\r\n                \r\n                let temp_second_coord=first_coordinate;\r\n                temp_second_coord[1]=temp_second_coord[1]+1;\r\n                while(temp_second_coord[1]<=second_coordinate[1]){\r\n                    if (!check_board(temp_second_coord)){\r\n                        alert(\"Please do not skip\");\r\n                        fail_return(gamestateRef.current.player_turn)\r\n                        return false;\r\n                        }\r\n                    temp_second_coord[1]=temp_second_coord[1]+1;\r\n                    }\r\n                    \r\n                }\r\n\r\n             else if(first_coordinate[0]!=second_coordinate[0]){\r\n                alert(\"Please place all in horizontal\")\r\n                fail_return(gamestateRef.current.player_turn)\r\n                return false;\r\n            } \r\n        } else if (direction==\"vertical\"){\r\n            if((first_coordinate[0]+1)!=second_coordinate[0] && first_coordinate[1]==second_coordinate[1]){\r\n                \r\n                let temp_second_coord=first_coordinate;\r\n                temp_second_coord[0]=temp_second_coord[0]+1;\r\n                while(temp_second_coord[0]<=second_coordinate[0]){\r\n                    if (!check_board(temp_second_coord)){\r\n                        alert(\"Please do not skip\");\r\n                        fail_return(gamestateRef.current.player_turn)\r\n                        return false;\r\n                        }\r\n                    temp_second_coord[0]=temp_second_coord[0]+1;\r\n                    }\r\n                    \r\n                }\r\n            } else if ((first_coordinate[1])!=second_coordinate[1]){\r\n                alert(\"Please place all in vertical\")\r\n                fail_return(gamestateRef.current.player_turn)\r\n                return false;\r\n            }\r\n        \r\n        \r\n        first_coordinate=second_coordinate;\r\n        if ((i+1)!=gamestateRef.current.just_added.length){\r\n            second_coordinate=tile_coordinate(gamestateRef.current.just_added[i+1])\r\n            }\r\n        }\r\n      }\r\n      return true\r\n    }\r\n\r\n    function vertical_words(new_tile,up,down){\r\n\r\n      let vertical_word_tile=[];\r\n      let prepend_up=false;\r\n  \r\n      if (check_board(up)){\r\n          prepend_up=true\r\n          vertical_word_tile.push([boardstateRef.current.blocks[new_tile]])\r\n              while(check_board(up)){\r\n                  vertical_word_tile[vertical_word_tile.length-1].unshift(boardstateRef.current.blocks[tile_index(up)])\r\n                  up[0]=up[0]-1;\r\n          }\r\n          \r\n      } \r\n      if (check_board(down)){\r\n          if (prepend_up==false){\r\n              vertical_word_tile.push([boardstateRef.current.blocks[new_tile]])}\r\n  \r\n          while(check_board(down)){\r\n              vertical_word_tile[vertical_word_tile.length-1].push(boardstateRef.current.blocks[tile_index(down)])\r\n              down[0]=down[0]+1;\r\n          }\r\n      }\r\n      return vertical_word_tile\r\n  }\r\n  function horizontal_words(new_tile,left,right){\r\n  \r\n      let horizontal_word_tile=[];\r\n      let prepend_left=false;\r\n      \r\n      if (check_board(left)) {\r\n          prepend_left=true\r\n          horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]])\r\n          while(check_board(left)){\r\n              horizontal_word_tile[horizontal_word_tile.length-1].unshift(boardstateRef.current.blocks[tile_index(left)])\r\n              left[1]=left[1]-1;\r\n              }\r\n          }\r\n          \r\n      if (check_board(right)){\r\n  \r\n          if (prepend_left==false){\r\n          horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]])}\r\n  \r\n          while(check_board(right)){\r\n              horizontal_word_tile[horizontal_word_tile.length-1].push(boardstateRef.current.blocks[tile_index(right)])\r\n              right[1]=right[1]+1;\r\n              }\r\n          }\r\n      return horizontal_word_tile\r\n          \r\n      }\r\n\r\n    function set_words_block(new_tiles){\r\n      let words=[];\r\n  \r\n      let coor=tile_coordinate(gamestateRef.current.just_added[0])\r\n      let up,down,left,right\r\n      up=coor.slice(0);\r\n      down=coor.slice(0);\r\n      left=coor.slice(0);\r\n      right=coor.slice(0);\r\n  \r\n      up[0]=up[0]-1;\r\n      down[0]=down[0]+1;\r\n      left[1]=left[1]-1;\r\n      right[1]=right[1]+1;\r\n      \r\n      if(new_tiles.length==1){      \r\n  \r\n          horizontal_words(gamestateRef.current.just_added[0],left,right).forEach(horizontal_word=>words.push(horizontal_word));\r\n          vertical_words(gamestateRef.current.just_added[0],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n          \r\n      }else{\r\n       \r\n          if (tile_coordinate(gamestateRef.current.just_added[0])[0]==tile_coordinate(gamestateRef.current.just_added[1])[0]){\r\n              //horizontal\r\n              horizontal_words(gamestateRef.current.just_added[0],left,right).forEach(horizontal_word=>words.push(horizontal_word));\r\n              for (let i =0 ; i<new_tiles.length;i++){\r\n                  \r\n                  vertical_words(new_tiles[i],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n          \r\n              }\r\n          }else{\r\n              //vertical\r\n              vertical_words(new_tiles[0],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n              for (let i =0 ; i<new_tiles.length;i++){\r\n                  horizontal_words(new_tiles[i],left,right).forEach(horizontal_word=>words.push(horizontal_word));       \r\n              }\r\n          } \r\n          }\r\n  \r\n      return words\r\n  }\r\n\r\n  function new_block_score(new_block){\r\n    let new_block_s=0\r\n    let double_word=0;\r\n    let triple_word=0;\r\n    \r\n    if (new_block.type==\"dw\" || new_block.type==\"st\"){\r\n        new_block_s += new_block.content.score;\r\n        double_word += 1;\r\n    } else if (new_block.type==\"tw\"){\r\n        new_block_s += new_block.content.score;\r\n        triple_word += 1;\r\n    } else if (new_block.type==\"dl\"){\r\n        new_block_s += new_block.content.score*2\r\n    } else if (new_block.type==\"tl\"){\r\n        new_block_s += new_block.content.score*3\r\n    }else{\r\n        new_block_s += new_block.content.score\r\n    }\r\n    return [new_block_s,double_word,triple_word]\r\n}\r\nfunction old_block_score(old_block){  \r\n    let old_tile_s=0;\r\n    old_tile_s += old_block.content.score\r\n    return old_tile_s\r\n\r\n}\r\n\r\nfunction word_score(word_blocks){\r\n\r\n    let individual_word_score=0;\r\n    var double_word=0;\r\n    var triple_word=0;\r\n  \r\n    for (let z=0; z<word_blocks.length; z++){\r\n\r\n        if (word_blocks[z].content.just_added==true){\r\n            let scores=new_block_score(word_blocks[z])\r\n            individual_word_score+=scores[0];\r\n            double_word+=scores[1];\r\n            triple_word+=scores[2]\r\n        } else{\r\n            individual_word_score+=old_block_score(word_blocks[z]);\r\n        }}\r\n    \r\n    if (double_word!=0){\r\n        individual_word_score = individual_word_score * 2 * double_word;\r\n    }\r\n\r\n    if (triple_word!=0){\r\n        individual_word_score = individual_word_score * 3 * triple_word;\r\n    }\r\n\r\n    \r\n    return individual_word_score \r\n}\r\n\r\n  function additionalscore(words){\r\n  \r\n    let extra_score=0; \r\n    \r\n    for (let y=0;y<words.length;y++){\r\n        extra_score+=word_score(words[y])\r\n    }\r\n\r\n    if (gamestateRef.current.just_added.length==7){\r\n        extra_score+=50;\r\n    }  \r\n    return extra_score\r\n}\r\n\r\n    function Score(){\r\n      \r\n      if(check_validity()){\r\n          let words_block=set_words_block(gamestateRef.current.just_added)\r\n          let updated_score=playerlistRef.current[gamestateRef.current.player_turn].score+additionalscore(words_block);\r\n          let sachet={...sachetstateRef.current}\r\n          Object.setPrototypeOf( sachet,sachetstateRef.current )\r\n          let drawn_tiles=playerlistRef.current[gamestateRef.current.player_turn].draw(sachet)          \r\n          setplayerlistState(prevplayerlistState=>{\r\n            let newplayerlistState=[...prevplayerlistState]\r\n            newplayerlistState[gamestateRef.current.player_turn].score=updated_score\r\n            newplayerlistState[gamestateRef.current.player_turn].draw_by_tiles(drawn_tiles);\r\n            return newplayerlistState\r\n          })\r\n          let words_alphabet=[]\r\n          for (let i=0;i<words_block.length;i++){\r\n            words_alphabet.push([\"\"])\r\n            for(let y=0;y<words_block[i].length;y++){\r\n              words_alphabet[i]+=words_block[i][y].content.alphabet\r\n            }\r\n          }\r\n          values.next_funct(sachet,words_alphabet,gamestateRef.current.player_turn)\r\n          \r\n          for (let i=0;i<drawn_tiles.length;i++){\r\n            drawn_tiles[i].canDrop=false\r\n            drawn_tiles[i].canDrag=false\r\n          }\r\n          websocket.current.emit(\"emit_updated_score\",{\r\n            room_id:gamestateRef.current.room_id,\r\n            player_turn:gamestateRef.current.player_turn,\r\n            score:updated_score,\r\n            challenge_words:words_alphabet,\r\n            challenge_index:gamestateRef.current.player_turn,\r\n            drawn_tiles:drawn_tiles})\r\n      }\r\n\r\n    }\r\n    useEffect(()=>{\r\n      websocket.current.on(\"update_player_score\",(socket_out)=>{\r\n        \r\n        let sachet2={...sachetstateRef.current}\r\n       \r\n        Object.setPrototypeOf( sachet2,sachetstateRef.current )\r\n        \r\n\r\n        sachet2.remove_by_tiles(socket_out.drawn_tiles)\r\n        let updated_container=playerlistRef.current[socket_out.player_turn].tiles.concat(socket_out.drawn_tiles)\r\n        setplayerlistState(prevplayerlistState=>{\r\n          let newplayerlistState=[...prevplayerlistState]\r\n          newplayerlistState[socket_out.player_turn].score=socket_out.score\r\n          newplayerlistState[socket_out.player_turn].tiles=updated_container\r\n          return newplayerlistState\r\n        })\r\n\r\n        values.next_funct(sachet2,socket_out.challenge_words,socket_out.challenge_index)\r\n      })\r\n    },[])\r\n    return(\r\n        <div>\r\n            <button type=\"button\" className=\"score_button gamesbtn\" style={scorestyle} onClick={Score} disabled={!scoreActive}>Score</button> \r\n        </div>)\r\n}\r\n\r\nexport default Score_button"]},"metadata":{},"sourceType":"module"}