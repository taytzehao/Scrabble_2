{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\TzeHaoTay\\\\Desktop\\\\CS\\\\scrabble2\\\\frontend\\\\src\\\\Games_page\\\\Action\\\\Score_button.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useContext, useEffect, useRef } from 'react';\nimport { UserContext } from '../../UserContext.js';\nimport { GamesContext, BlocksContext, PlayerListContext, AnalyticsDataContext } from '../GamesContext.js';\nimport { analytics_data } from '../Sachet.js';\nimport { games_sachet } from '../Gamespage.js';\nimport './Actionbar.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Score_button(values) {\n  _s();\n\n  const {\n    profile,\n    setprofile\n  } = useContext(UserContext);\n  const {\n    playerlistState,\n    setplayerlistState\n  } = useContext(PlayerListContext);\n  const {\n    gameState,\n    setgameState\n  } = useContext(GamesContext);\n  const {\n    boardState,\n    setboardState\n  } = useContext(BlocksContext);\n  const {\n    analyticsdataState,\n    setanalyticsdataState\n  } = useContext(AnalyticsDataContext);\n  const playerlistRef = useRef(null);\n  const gamestateRef = useRef(null);\n  const boardstateRef = useRef(null);\n  playerlistRef.current = playerlistState;\n  gamestateRef.current = gameState;\n  boardstateRef.current = boardState;\n  const [scoreActive, setscoreActive] = useState(false);\n  console.log(\"List 2\", playerlistState);\n  useEffect(() => {\n    if (gameState.player_turn == gameState.your_index && !playerlistState[gameState.your_index].delete_list) {\n      setscoreActive(true);\n    } else {\n      setscoreActive(false);\n    }\n  }, [gamestateRef.current.player_turn, playerlistRef.current[gamestateRef.current.your_index].delete_list]);\n\n  function fail_return(player_turn) {\n    let return_tiles = [];\n\n    for (let i = 0; i < gamestateRef.current.just_added.length; i++) {\n      return_tiles.push(boardstateRef.current.blocks[gamestateRef.current.just_added[i]].content);\n      return_tiles[i].just_added = false;\n      return_tiles[i].placed = false;\n      return_tiles[i].canDrop = true;\n      return_tiles[i].container_index = playerlistRef.current[player_turn].tiles.length + i;\n    }\n\n    setplayerlistState(prevplayerlistState => {\n      let newplayerlistState = [...prevplayerlistState];\n      newplayerlistState[player_turn].tiles = newplayerlistState[player_turn].tiles.concat(return_tiles);\n      return newplayerlistState;\n    });\n    setboardState(prevboardState => {\n      let newboardState = [...prevboardState];\n      gamestateRef.current.just_added.forEach(index => {\n        newboardState.blocks[index].content = null;\n      });\n    });\n  }\n\n  function tile_coordinate(index) {\n    let row = Math.floor(index / boardstateRef.current.column_length);\n    let column = index % boardstateRef.current.column_length;\n    return [row, column];\n  }\n\n  function tile_index(coordinate) {\n    return coordinate[0] * boardstateRef.current.column_length + coordinate[1];\n  }\n\n  function check_board(coordinate) {\n    if (coordinate[0] < 0 || coordinate[0] >= boardstateRef.current.row_length || coordinate[1] < 0 || coordinate[1] >= boardstateRef.current.column_length) {\n      return false;\n    }\n\n    let index = tile_index(coordinate);\n\n    if (boardstateRef.current.blocks[index].content) {\n      if (boardstateRef.current.blocks[index].content.placed) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function check_validity() {\n    if (gamestateRef.current.turn_num == 0) {\n      let start_block = boardstateRef.current.blocks.find(block => block.type == \"st\");\n\n      if (!start_block.content) {\n        alert(\"Please place the tile on the start block.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n    } else {\n      let attached = false;\n\n      for (let i = 0; i < gamestateRef.current.just_added.length; i++) {\n        let coor = tile_coordinate(gamestateRef.current.just_added[i]);\n        let up, down, left, right;\n        up = down = left = right = coor;\n        up[0] = up[0] - 1;\n        down[0] = down[0] + 1;\n        left[1] = left[1] - 1;\n        right[1] = right[1] + 1;\n\n        if (check_board(up) || check_board(down) || check_board(left) || check_board(right)) {\n          attached = true;\n          break;\n        }\n      }\n\n      if (attached == false) {\n        alert(\"Please place your tiles adjacent to an existing tile.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n    }\n\n    if (gamestateRef.current.just_added.length > 1) {\n      let first_coordinate = tile_coordinate(gamestateRef.current.just_added[0]);\n      let second_coordinate = tile_coordinate(gamestateRef.current.just_added[1]);\n\n      if (first_coordinate[0] == second_coordinate[0]) {\n        var direction = \"horizontal\";\n      } else if (first_coordinate[1] == second_coordinate[1]) {\n        var direction = \"vertical\";\n      } else {\n        alert(\"Your sequence of tiles must either be in horizontal or vertical form, adjacent to each other.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n\n      for (let i = 1; i < gamestateRef.current.just_added; i++) {\n        if (direction == \"horizontal\") {\n          if (first_coordinate[1] + 1 != second_coordinate[1] && first_coordinate[0] == second_coordinate[0]) {\n            let temp_second_coord = first_coordinate;\n            temp_second_coord[1] = temp_second_coord[1] + 1;\n\n            while (temp_second_coord[1] <= second_coordinate[1]) {\n              if (!check_board(temp_second_coord)) {\n                alert(\"Please do not skip\");\n                fail_return(gamestateRef.current.player_turn);\n                return false;\n              }\n\n              temp_second_coord[1] = temp_second_coord[1] + 1;\n            }\n          } else if (first_coordinate[0] != second_coordinate[0]) {\n            alert(\"Please place all in horizontal\");\n            fail_return(gamestateRef.current.player_turn);\n            return false;\n          }\n        } else if (direction == \"vertical\") {\n          if (first_coordinate[0] + 1 != second_coordinate[0] && first_coordinate[1] == second_coordinate[1]) {\n            let temp_second_coord = first_coordinate;\n            temp_second_coord[0] = temp_second_coord[0] + 1;\n\n            while (temp_second_coord[0] <= second_coordinate[0]) {\n              if (!check_board(temp_second_coord)) {\n                alert(\"Please do not skip\");\n                fail_return(gamestateRef.current.player_turn);\n                return false;\n              }\n\n              temp_second_coord[0] = temp_second_coord[0] + 1;\n            }\n          }\n        } else if (first_coordinate[1] != second_coordinate[1]) {\n          alert(\"Please place all in vertical\");\n          fail_return(gamestateRef.current.player_turn);\n          return false;\n        }\n\n        first_coordinate = second_coordinate;\n\n        if (i + 1 != gamestateRef.current.just_added.length) {\n          second_coordinate = tile_coordinate(gamestateRef.current.just_added[i + 1]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function vertical_words(new_tile, up, down) {\n    let vertical_word_tile = [];\n    let prepend_up = false;\n\n    if (check_board(up)) {\n      prepend_up = true;\n      vertical_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n\n      while (check_board(up)) {\n        vertical_word_tile[vertical_word_tile.length - 1].unshift(boardstateRef.current.blocks[tile_index(up)]);\n        up[0] = up[0] - 1;\n      }\n    }\n\n    if (check_board(down)) {\n      if (prepend_up == false) {\n        vertical_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n      }\n\n      while (check_board(down)) {\n        vertical_word_tile[vertical_word_tile.length - 1].push(boardstateRef.current.blocks[tile_index(down)]);\n        down[0] = down[0] + 1;\n      }\n    }\n\n    return vertical_word_tile;\n  }\n\n  function horizontal_words(new_tile, left, right) {\n    let horizontal_word_tile = [];\n    let prepend_left = false;\n\n    if (check_board(left)) {\n      prepend_left = true;\n      horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n\n      while (check_board(left)) {\n        horizontal_word_tile[horizontal_word_tile.length - 1].unshift(boardstateRef.current.blocks[tile_index(left)]);\n        left[1] = left[1] - 1;\n      }\n    }\n\n    if (check_board(right)) {\n      if (prepend_left == false) {\n        horizontal_word_tile.push([new_tile]);\n      }\n\n      while (check_board(right)) {\n        horizontal_word_tile[horizontal_word_tile.length - 1].push(boardstateRef.current.blocks[tile_index(right)]);\n        right[1] = right[1] + 1;\n      }\n    }\n\n    return horizontal_word_tile;\n  }\n\n  function words_block(new_tiles) {\n    let words = [];\n    let coor = tile_coordinate(gamestateRef.current.just_added[0]);\n    let up, down, left, right;\n    up = coor.slice(0);\n    down = coor.slice(0);\n    left = coor.slice(0);\n    right = coor.slice(0);\n    up[0] = up[0] - 1;\n    down[0] = down[0] + 1;\n    left[1] = left[1] - 1;\n    right[1] = right[1] + 1;\n\n    if (new_tiles.length == 1) {\n      horizontal_words(gamestateRef.current.just_added[0], left, right).forEach(horizontal_word => words.push(horizontal_word));\n      vertical_words(gamestateRef.current.just_added[0], up, down).forEach(vertical_word => words.push(vertical_word));\n    } else {\n      if (tile_coordinate(gamestateRef.current.just_added[0])[0] == tile_coordinate(gamestateRef.current.just_added[1])[0]) {\n        //horizontal\n        horizontal_words(gamestateRef.current.just_added[0], left, right).forEach(horizontal_word => words.push(horizontal_word));\n\n        for (let i = 0; i < new_tiles.length; i++) {\n          vertical_words(new_tiles[i], up, down).forEach(vertical_word => words.push(vertical_word));\n        }\n      } else {\n        //vertical\n        vertical_words(new_tiles[0], up, down).forEach(vertical_word => words.push(vertical_word));\n\n        for (let i = 0; i < new_tiles.length; i++) {\n          horizontal_words(new_tiles[i], left, right).forEach(horizontal_word => words.push(horizontal_word));\n        }\n      }\n    }\n\n    return words;\n  }\n\n  function new_block_score(new_block) {\n    let new_block_s = 0;\n    let double_word = 0;\n    let triple_word = 0;\n\n    if (new_block.type != \"default\") {\n      console.log(new_block.type);\n\n      if (new_block.type == \"dw\") {\n        new_block_s += new_block.content.score;\n        double_word += 1;\n      } else if (new_block.type == \"tw\") {\n        new_block_s += new_block.content.score;\n        triple_word += 1;\n      } else if (new_block.type == \"dl\") {\n        new_block_s += new_block.content.score * 2;\n      } else if (new_block.type == \"tl\") {\n        new_block_s += new_block.content.score * 3;\n      }\n    } else {\n      new_block_s += new_block.content.score;\n    }\n\n    return [new_block_s, double_word, triple_word];\n  }\n\n  function old_block_score(old_block) {\n    let old_tile_s = 0;\n    old_tile_s += old_block.content.score;\n    return old_tile_s;\n  }\n\n  function word_score(word_blocks) {\n    let individual_word_score = 0;\n    var double_word;\n    var triple_word = 0;\n\n    if (gamestateRef.current.turn_num == 0) {\n      double_word = 1;\n    } else {\n      double_word = 0;\n    }\n\n    for (let z = 0; z < word_blocks.length; z++) {\n      if (word_blocks.content.just_added == true) {\n        let scores = new_block_score(word_blocks[z]);\n        individual_word_score += scores[0];\n        double_word += scores[1];\n        triple_word += scores[2];\n      } else {\n        individual_word_score += old_block_score(word_blocks[z]);\n      }\n    }\n\n    if (double_word != 0) {\n      individual_word_score = individual_word_score * 2 * double_word;\n    }\n\n    if (triple_word != 0) {\n      individual_word_score = individual_word_score * 3 * triple_word;\n    }\n\n    return individual_word_score;\n  }\n\n  function additionalscore(words) {\n    let extra_score = 0;\n\n    for (let y = 0; y < words.length; y++) {\n      extra_score += word_score(words[y]);\n    }\n\n    if (gamestateRef.current.just_added.length == 7) {\n      extra_score += 50;\n    }\n\n    return extra_score;\n  }\n\n  function Score() {\n    if (check_validity()) {\n      let words = words_block();\n      let updated_score = playerlistRef[gamestateRef.current.player_turn] + additionalscore(words);\n      let drawn_tiles = playerlistRef[gamestateRef.current.player_turn].draw();\n      gamestateRef.current.socket.emit(\"emit_updated_score\", {\n        room_id: gamestateRef.current.room_id,\n        player_turn: gamestateRef.current.player_turn,\n        score: updated_score,\n        tiles: drawn_tiles\n      });\n      setplayerlistState(prevplayerlistState => {\n        let newplayerlistState = [...prevplayerlistState];\n        newplayerlistState[gamestateRef.current.player_turn].score = updated_score;\n        newplayerlistState[gamestateRef.current.player_turn].tiles = newplayerlistState[gamestateRef.current.player_turn].tiles.concat(drawn_tiles);\n        return newplayerlistState;\n      });\n      values.next_func();\n    }\n  }\n\n  useEffect(() => {\n    gamestateRef.current.socket.current.on(\"update_player_score\", socket_out => {\n      let added_tiles = socket_out.tiles.filter(tile => !playerlistRef.current[socket_out.player_turn].find(element => element.id == tile.id));\n      setplayerlistState(prevplayerlistState => {\n        let newplayerlistState = [...prevplayerlistState];\n        newplayerlistState[gamestateRef.current.player_turn].score = socket_out.updated_score;\n        newplayerlistState[gamestateRef.current.player_turn].draw_by_alphabets(socket_out.tiles);\n        return newplayerlistState;\n      });\n      values.next_func();\n    });\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"button\", {\n      type: \"button\",\n      className: \"score_button\",\n      onClick: Score,\n      disabled: !scoreActive,\n      children: \"Score\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 377,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 376,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Score_button, \"qwFq1JmKljcnmZzotK/MVifqmG4=\");\n\n_c = Score_button;\nexport default Score_button;\n\nvar _c;\n\n$RefreshReg$(_c, \"Score_button\");","map":{"version":3,"sources":["C:/Users/TzeHaoTay/Desktop/CS/scrabble2/frontend/src/Games_page/Action/Score_button.js"],"names":["React","useState","useContext","useEffect","useRef","UserContext","GamesContext","BlocksContext","PlayerListContext","AnalyticsDataContext","analytics_data","games_sachet","Score_button","values","profile","setprofile","playerlistState","setplayerlistState","gameState","setgameState","boardState","setboardState","analyticsdataState","setanalyticsdataState","playerlistRef","gamestateRef","boardstateRef","current","scoreActive","setscoreActive","console","log","player_turn","your_index","delete_list","fail_return","return_tiles","i","just_added","length","push","blocks","content","placed","canDrop","container_index","tiles","prevplayerlistState","newplayerlistState","concat","prevboardState","newboardState","forEach","index","tile_coordinate","row","Math","floor","column_length","column","tile_index","coordinate","check_board","row_length","check_validity","turn_num","start_block","find","block","type","alert","attached","coor","up","down","left","right","first_coordinate","second_coordinate","direction","temp_second_coord","vertical_words","new_tile","vertical_word_tile","prepend_up","unshift","horizontal_words","horizontal_word_tile","prepend_left","words_block","new_tiles","words","slice","horizontal_word","vertical_word","new_block_score","new_block","new_block_s","double_word","triple_word","score","old_block_score","old_block","old_tile_s","word_score","word_blocks","individual_word_score","z","scores","additionalscore","extra_score","y","Score","updated_score","drawn_tiles","draw","socket","emit","room_id","next_func","on","socket_out","added_tiles","filter","tile","element","id","draw_by_alphabets"],"mappings":"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","sourcesContent":["import React, {useState,useContext,useEffect,useRef} from 'react';\r\nimport {UserContext} from '../../UserContext.js'\r\nimport {GamesContext,BlocksContext,PlayerListContext,AnalyticsDataContext} from '../GamesContext.js'\r\nimport { analytics_data } from '../Sachet.js';\r\nimport {games_sachet} from '../Gamespage.js'\r\nimport './Actionbar.css'\r\n\r\nfunction Score_button(values){\r\n  const {profile,setprofile}=useContext(UserContext)\r\n  const {playerlistState,setplayerlistState}=useContext(PlayerListContext)\r\n  const {gameState,setgameState}=useContext(GamesContext)   \r\n  const {boardState,setboardState}=useContext(BlocksContext)\r\n  const {analyticsdataState,setanalyticsdataState}=useContext(AnalyticsDataContext)\r\n  const playerlistRef=useRef(null);\r\n  const gamestateRef=useRef(null);\r\n  const boardstateRef=useRef(null);\r\n  playerlistRef.current=playerlistState\r\n  gamestateRef.current=gameState\r\n  boardstateRef.current=boardState\r\n    const [scoreActive,setscoreActive]=useState(false)\r\n    console.log(\"List 2\",playerlistState)\r\n    useEffect(()=>{ \r\n        if(gameState.player_turn==gameState.your_index && !playerlistState[gameState.your_index].delete_list){\r\n          setscoreActive(true)\r\n        }else{\r\n          setscoreActive(false)\r\n        }\r\n      },[gamestateRef.current.player_turn,playerlistRef.current.[gamestateRef.current.your_index].delete_list])\r\n    \r\n    function fail_return(player_turn){\r\n      let return_tiles=[]\r\n      for (let i=0;i<gamestateRef.current.just_added.length;i++){\r\n        return_tiles.push(boardstateRef.current.blocks[gamestateRef.current.just_added[i]].content)\r\n        return_tiles[i].just_added=false\r\n        return_tiles[i].placed=false\r\n        return_tiles[i].canDrop=true\r\n        return_tiles[i].container_index=playerlistRef.current[player_turn].tiles.length+i\r\n      }\r\n      setplayerlistState((prevplayerlistState=>{\r\n        let newplayerlistState=[...prevplayerlistState]\r\n        newplayerlistState[player_turn].tiles=newplayerlistState[player_turn].tiles.concat(return_tiles)\r\n        return newplayerlistState\r\n      }))\r\n      setboardState((prevboardState=>{\r\n        let newboardState=[...prevboardState]\r\n        gamestateRef.current.just_added.forEach(index=>{\r\n          newboardState.blocks[index].content=null\r\n        })\r\n      }))\r\n    }\r\n    function tile_coordinate(index){\r\n      let row = Math.floor(index / boardstateRef.current.column_length)\r\n      let column=index%boardstateRef.current.column_length\r\n      return [row,column]\r\n    }\r\n    function tile_index(coordinate){\r\n      return coordinate[0]*boardstateRef.current.column_length+coordinate[1];\r\n    }\r\n    function check_board(coordinate){\r\n      if (coordinate[0]<0 || coordinate[0]>=boardstateRef.current.row_length || coordinate[1]<0 || coordinate[1]>=boardstateRef.current.column_length){\r\n        return false\r\n    }\r\n      let index=tile_index(coordinate)\r\n      if(boardstateRef.current.blocks[index].content){\r\n        if(boardstateRef.current.blocks[index].content.placed){return true}\r\n      }\r\n      return false\r\n\r\n    }\r\n\r\n    function check_validity(){\r\n      if (gamestateRef.current.turn_num==0){\r\n        let start_block=boardstateRef.current.blocks.find(block=>block.type==\"st\")\r\n        if(!start_block.content){\r\n          alert(\"Please place the tile on the start block.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false\r\n        }\r\n      }else{\r\n        let attached=false;\r\n        for(let i=0;i<gamestateRef.current.just_added.length;i++){\r\n          let coor=tile_coordinate(gamestateRef.current.just_added[i])\r\n          let up,down,left,right;\r\n          up=down=left=right=coor;\r\n\r\n          up[0]=up[0]-1;\r\n          down[0]=down[0]+1;\r\n          left[1]=left[1]-1;\r\n          right[1]=right[1]+1;\r\n\r\n            if (check_board(up)||check_board(down)||check_board(left)||check_board(right)){\r\n                attached=true;\r\n                break;\r\n            }    \r\n        }\r\n        if (attached==false){\r\n          alert (\"Please place your tiles adjacent to an existing tile.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false;\r\n        }\r\n      }\r\n      if(gamestateRef.current.just_added.length>1){\r\n        let first_coordinate=tile_coordinate(gamestateRef.current.just_added[0]);\r\n        let second_coordinate=tile_coordinate(gamestateRef.current.just_added[1]);\r\n\r\n        if (first_coordinate[0]==second_coordinate[0] ){\r\n          var direction =\"horizontal\";\r\n      } else if (first_coordinate[1]==second_coordinate[1]){\r\n          var direction =\"vertical\";\r\n      } else {\r\n          alert (\"Your sequence of tiles must either be in horizontal or vertical form, adjacent to each other.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false;\r\n      }\r\n      for (let i =1 ; i<gamestateRef.current.just_added;i++){\r\n        if (direction==\"horizontal\"){\r\n             if ((first_coordinate[1]+1)!=second_coordinate[1] && first_coordinate[0]==second_coordinate[0]){\r\n                \r\n                let temp_second_coord=first_coordinate;\r\n                temp_second_coord[1]=temp_second_coord[1]+1;\r\n                while(temp_second_coord[1]<=second_coordinate[1]){\r\n                    if (!check_board(temp_second_coord)){\r\n                        alert(\"Please do not skip\");\r\n                        fail_return(gamestateRef.current.player_turn)\r\n                        return false;\r\n                        }\r\n                    temp_second_coord[1]=temp_second_coord[1]+1;\r\n                    }\r\n                    \r\n                }\r\n\r\n             else if(first_coordinate[0]!=second_coordinate[0]){\r\n                alert(\"Please place all in horizontal\")\r\n                fail_return(gamestateRef.current.player_turn)\r\n                return false;\r\n            } \r\n        } else if (direction==\"vertical\"){\r\n            if((first_coordinate[0]+1)!=second_coordinate[0] && first_coordinate[1]==second_coordinate[1]){\r\n                \r\n                let temp_second_coord=first_coordinate;\r\n                temp_second_coord[0]=temp_second_coord[0]+1;\r\n                while(temp_second_coord[0]<=second_coordinate[0]){\r\n                    if (!check_board(temp_second_coord)){\r\n                        alert(\"Please do not skip\");\r\n                        fail_return(gamestateRef.current.player_turn)\r\n                        return false;\r\n                        }\r\n                    temp_second_coord[0]=temp_second_coord[0]+1;\r\n                    }\r\n                    \r\n                }\r\n            } else if ((first_coordinate[1])!=second_coordinate[1]){\r\n                alert(\"Please place all in vertical\")\r\n                fail_return(gamestateRef.current.player_turn)\r\n                return false;\r\n            }\r\n        \r\n        \r\n        first_coordinate=second_coordinate;\r\n        if ((i+1)!=gamestateRef.current.just_added.length){\r\n            second_coordinate=tile_coordinate(gamestateRef.current.just_added[i+1])\r\n            }\r\n        }\r\n      }\r\n      return true\r\n    }\r\n\r\n    function vertical_words(new_tile,up,down){\r\n\r\n      let vertical_word_tile=[];\r\n      let prepend_up=false;\r\n  \r\n      if (check_board(up)){\r\n          prepend_up=true\r\n          vertical_word_tile.push([boardstateRef.current.blocks[new_tile]])\r\n              while(check_board(up)){\r\n                  vertical_word_tile[vertical_word_tile.length-1].unshift(boardstateRef.current.blocks[tile_index(up)])\r\n                  up[0]=up[0]-1;\r\n          }\r\n          \r\n      } \r\n      if (check_board(down)){\r\n          if (prepend_up==false){\r\n              vertical_word_tile.push([boardstateRef.current.blocks[new_tile]])}\r\n  \r\n          while(check_board(down)){\r\n              vertical_word_tile[vertical_word_tile.length-1].push(boardstateRef.current.blocks[tile_index(down)])\r\n              down[0]=down[0]+1;\r\n          }\r\n      }\r\n      return vertical_word_tile\r\n  }\r\n  function horizontal_words(new_tile,left,right){\r\n  \r\n      let horizontal_word_tile=[];\r\n      let prepend_left=false;\r\n      \r\n      if (check_board(left)) {\r\n          prepend_left=true\r\n          horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]])\r\n          while(check_board(left)){\r\n              horizontal_word_tile[horizontal_word_tile.length-1].unshift(boardstateRef.current.blocks[tile_index(left)])\r\n              left[1]=left[1]-1;\r\n              }\r\n          }\r\n          \r\n      if (check_board(right)){\r\n  \r\n          if (prepend_left==false){\r\n          horizontal_word_tile.push([new_tile])}\r\n  \r\n          while(check_board(right)){\r\n              horizontal_word_tile[horizontal_word_tile.length-1].push(boardstateRef.current.blocks[tile_index(right)])\r\n              right[1]=right[1]+1;\r\n              }\r\n          }\r\n      return horizontal_word_tile\r\n          \r\n      }\r\n\r\n    function words_block(new_tiles){\r\n      let words=[];\r\n  \r\n      let coor=tile_coordinate(gamestateRef.current.just_added[0])\r\n      let up,down,left,right\r\n      up=coor.slice(0);\r\n      down=coor.slice(0);\r\n      left=coor.slice(0);\r\n      right=coor.slice(0);\r\n  \r\n      up[0]=up[0]-1;\r\n      down[0]=down[0]+1;\r\n      left[1]=left[1]-1;\r\n      right[1]=right[1]+1;\r\n      \r\n      if(new_tiles.length==1){      \r\n  \r\n          horizontal_words(gamestateRef.current.just_added[0],left,right).forEach(horizontal_word=>words.push(horizontal_word));\r\n          vertical_words(gamestateRef.current.just_added[0],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n          \r\n      }else{\r\n       \r\n          if (tile_coordinate(gamestateRef.current.just_added[0])[0]==tile_coordinate(gamestateRef.current.just_added[1])[0]){\r\n              //horizontal\r\n              horizontal_words(gamestateRef.current.just_added[0],left,right).forEach(horizontal_word=>words.push(horizontal_word));\r\n              for (let i =0 ; i<new_tiles.length;i++){\r\n                  \r\n                  vertical_words(new_tiles[i],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n          \r\n              }\r\n          }else{\r\n              //vertical\r\n              vertical_words(new_tiles[0],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n              for (let i =0 ; i<new_tiles.length;i++){\r\n                  horizontal_words(new_tiles[i],left,right).forEach(horizontal_word=>words.push(horizontal_word));       \r\n              }\r\n          } \r\n          }\r\n  \r\n      return words\r\n  }\r\n\r\n  function new_block_score(new_block){\r\n    let new_block_s=0\r\n    let double_word=0;\r\n    let triple_word=0;\r\n    if (new_block.type!=\"default\"){\r\n    console.log(new_block.type)\r\n    if (new_block.type==\"dw\"){\r\n        new_block_s += new_block.content.score;\r\n        double_word += 1;\r\n    } else if (new_block.type==\"tw\"){\r\n        new_block_s += new_block.content.score;\r\n        triple_word += 1;\r\n    } else if (new_block.type==\"dl\"){\r\n        new_block_s += new_block.content.score*2\r\n    } else if (new_block.type==\"tl\"){\r\n        new_block_s += new_block.content.score*3\r\n        } \r\n    }else {\r\n        new_block_s += new_block.content.score\r\n    }\r\n    return [new_block_s,double_word,triple_word]\r\n}\r\nfunction old_block_score(old_block){  \r\n    let old_tile_s=0;\r\n    old_tile_s += old_block.content.score\r\n    return old_tile_s\r\n\r\n}\r\n\r\nfunction word_score(word_blocks){\r\n\r\n    let individual_word_score=0;\r\n    var double_word;\r\n    var triple_word=0;\r\n\r\n    if (gamestateRef.current.turn_num==0){\r\n        double_word=1;\r\n    }else{\r\n        double_word=0;\r\n    }\r\n  \r\n    for (let z=0; z<word_blocks.length; z++){\r\n\r\n        if (word_blocks.content.just_added==true){\r\n            let scores=new_block_score(word_blocks[z])\r\n            individual_word_score+=scores[0];\r\n            double_word+=scores[1];\r\n            triple_word+=scores[2]\r\n        } else{\r\n            individual_word_score+=old_block_score(word_blocks[z]);\r\n        }}\r\n    \r\n    if (double_word!=0){\r\n        individual_word_score = individual_word_score * 2 * double_word;\r\n    }\r\n\r\n    if (triple_word!=0){\r\n        individual_word_score = individual_word_score * 3 * triple_word;\r\n    }\r\n\r\n    \r\n    return individual_word_score \r\n}\r\n\r\n  function additionalscore(words){\r\n  \r\n    let extra_score=0; \r\n    \r\n    for (let y=0;y<words.length;y++){\r\n        extra_score+=word_score(words[y])\r\n    }\r\n\r\n    if (gamestateRef.current.just_added.length==7){\r\n        extra_score+=50;\r\n    }  \r\n    return extra_score\r\n}\r\n\r\n    function Score(){\r\n      \r\n      if(check_validity()){\r\n          let words=words_block()\r\n          let updated_score=playerlistRef[gamestateRef.current.player_turn]+additionalscore(words);\r\n          let drawn_tiles=playerlistRef[gamestateRef.current.player_turn].draw()\r\n          gamestateRef.current.socket.emit(\"emit_updated_score\",{\r\n            room_id:gamestateRef.current.room_id,\r\n            player_turn:gamestateRef.current.player_turn,\r\n            score:updated_score,\r\n            tiles:drawn_tiles})\r\n          \r\n          setplayerlistState(prevplayerlistState=>{\r\n            let newplayerlistState=[...prevplayerlistState]\r\n            newplayerlistState[gamestateRef.current.player_turn].score=updated_score\r\n            newplayerlistState[gamestateRef.current.player_turn].tiles=newplayerlistState[gamestateRef.current.player_turn].tiles.concat(drawn_tiles);\r\n            return newplayerlistState\r\n          })\r\n          values.next_func()\r\n      }\r\n\r\n    }\r\n    useEffect(()=>{\r\n      gamestateRef.current.socket.current.on(\"update_player_score\",(socket_out)=>{\r\n        let added_tiles=socket_out.tiles.filter(tile=>!playerlistRef.current[socket_out.player_turn].find(element=>element.id==tile.id))\r\n        setplayerlistState(prevplayerlistState=>{\r\n          let newplayerlistState=[...prevplayerlistState]\r\n          newplayerlistState[gamestateRef.current.player_turn].score=socket_out.updated_score\r\n          newplayerlistState[gamestateRef.current.player_turn].draw_by_alphabets(socket_out.tiles);\r\n          return newplayerlistState\r\n        })\r\n        values.next_func()\r\n      })\r\n    },[])\r\n    return(\r\n        <div>\r\n            <button type=\"button\" className=\"score_button\" onClick={Score} disabled={!scoreActive}>Score</button> \r\n        </div>)\r\n}\r\n\r\nexport default Score_button"]},"metadata":{},"sourceType":"module"}