{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\TzeHaoTay\\\\Desktop\\\\CS\\\\scrabble2\\\\frontend\\\\src\\\\Games_page\\\\Action\\\\Score_button.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useContext, useEffect, useRef } from 'react';\nimport { UserContext } from '../../UserContext.js';\nimport { GamesContext, BlocksContext, PlayerListContext, AnalyticsDataContext, SachetContext } from '../GamesContext.js';\nimport sachet, { analytics_data } from '../Sachet.js';\nimport { games_sachet } from '../Gamespage.js';\nimport './Actionbar.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Score_button(values) {\n  _s();\n\n  const {\n    profile,\n    setprofile\n  } = useContext(UserContext);\n  const {\n    playerlistState,\n    setplayerlistState\n  } = useContext(PlayerListContext);\n  const {\n    gameState,\n    setgameState\n  } = useContext(GamesContext);\n  const {\n    boardState,\n    setboardState\n  } = useContext(BlocksContext);\n  const {\n    analyticsdataState,\n    setanalyticsdataState\n  } = useContext(AnalyticsDataContext);\n  const {\n    sachetState,\n    setsachetState\n  } = useContext(SachetContext);\n  const playerlistRef = useRef(null);\n  const gamestateRef = useRef(null);\n  const boardstateRef = useRef(null);\n  const sachetstateRef = useRef(null);\n  playerlistRef.current = playerlistState;\n  gamestateRef.current = gameState;\n  boardstateRef.current = boardState;\n  sachetstateRef.current = sachetState;\n  const [scoreActive, setscoreActive] = useState(false);\n  useEffect(() => {\n    if (gameState.player_turn == gameState.your_index && !playerlistState[gameState.your_index].delete_list.length) {\n      setscoreActive(true);\n    } else {\n      setscoreActive(false);\n    }\n  }, [gamestateRef.current.player_turn, playerlistRef.current[gamestateRef.current.your_index].delete_list]);\n\n  function fail_return(player_turn) {\n    let return_tiles = [];\n\n    for (let i = 0; i < gamestateRef.current.just_added.length; i++) {\n      return_tiles.push(boardstateRef.current.blocks[gamestateRef.current.just_added[i]].content);\n      return_tiles[i].just_added = false;\n      return_tiles[i].placed = false;\n      return_tiles[i].canDrop = true;\n      return_tiles[i].container_index = playerlistRef.current[player_turn].tiles.length + i;\n    }\n\n    gamestateRef.current.socket.current.emit(\"emit_fail_return\", {\n      return_tiles: return_tiles,\n      room_id: gamestateRef.current.room_id,\n      just_added: gamestateRef.current.just_added\n    });\n    setplayerlistState(prevplayerlistState => {\n      let newplayerlistState = [...prevplayerlistState];\n      newplayerlistState[player_turn].tiles = newplayerlistState[player_turn].tiles.concat(return_tiles);\n      return newplayerlistState;\n    });\n    setboardState(prevboardState => {\n      let newboardState = { ...prevboardState\n      };\n      gamestateRef.current.just_added.forEach(index => {\n        newboardState.blocks[index].content = null;\n      });\n      return newboardState;\n    });\n    setgameState(prevgameState => ({ ...prevgameState,\n      just_added: []\n    }));\n  }\n\n  function tile_coordinate(index) {\n    let row = Math.floor(index / boardstateRef.current.column_length);\n    let column = index % boardstateRef.current.column_length;\n    return [row, column];\n  }\n\n  function tile_index(coordinate) {\n    return coordinate[0] * boardstateRef.current.column_length + coordinate[1];\n  }\n\n  function check_board(coordinate) {\n    if (coordinate[0] < 0 || coordinate[0] >= boardstateRef.current.row_length || coordinate[1] < 0 || coordinate[1] >= boardstateRef.current.column_length) {\n      return false;\n    }\n\n    let index = tile_index(coordinate);\n\n    if (boardstateRef.current.blocks[index].content) {\n      if (boardstateRef.current.blocks[index].content.placed) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function check_validity() {\n    if (gamestateRef.current.turn_num == 0) {\n      let start_block = boardstateRef.current.blocks.find(block => block.type == \"st\");\n\n      if (!start_block.content) {\n        alert(\"Please place the tile on the start block.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n    } else {\n      let attached = false;\n\n      for (let i = 0; i < gamestateRef.current.just_added.length; i++) {\n        let coor = tile_coordinate(gamestateRef.current.just_added[i]);\n        let up, down, left, right;\n        up = down = left = right = coor;\n        up[0] = up[0] - 1;\n        down[0] = down[0] + 1;\n        left[1] = left[1] - 1;\n        right[1] = right[1] + 1;\n\n        if (check_board(up) || check_board(down) || check_board(left) || check_board(right)) {\n          attached = true;\n          break;\n        }\n      }\n\n      if (attached == false) {\n        alert(\"Please place your tiles adjacent to an existing tile.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n    }\n\n    if (gamestateRef.current.just_added.length > 1) {\n      let first_coordinate = tile_coordinate(gamestateRef.current.just_added[0]);\n      let second_coordinate = tile_coordinate(gamestateRef.current.just_added[1]);\n\n      if (first_coordinate[0] == second_coordinate[0]) {\n        var direction = \"horizontal\";\n      } else if (first_coordinate[1] == second_coordinate[1]) {\n        var direction = \"vertical\";\n      } else {\n        alert(\"Your sequence of tiles must either be in horizontal or vertical form, adjacent to each other.\");\n        fail_return(gamestateRef.current.player_turn);\n        return false;\n      }\n\n      for (let i = 1; i < gamestateRef.current.just_added; i++) {\n        if (direction == \"horizontal\") {\n          if (first_coordinate[1] + 1 != second_coordinate[1] && first_coordinate[0] == second_coordinate[0]) {\n            let temp_second_coord = first_coordinate;\n            temp_second_coord[1] = temp_second_coord[1] + 1;\n\n            while (temp_second_coord[1] <= second_coordinate[1]) {\n              if (!check_board(temp_second_coord)) {\n                alert(\"Please do not skip\");\n                fail_return(gamestateRef.current.player_turn);\n                return false;\n              }\n\n              temp_second_coord[1] = temp_second_coord[1] + 1;\n            }\n          } else if (first_coordinate[0] != second_coordinate[0]) {\n            alert(\"Please place all in horizontal\");\n            fail_return(gamestateRef.current.player_turn);\n            return false;\n          }\n        } else if (direction == \"vertical\") {\n          if (first_coordinate[0] + 1 != second_coordinate[0] && first_coordinate[1] == second_coordinate[1]) {\n            let temp_second_coord = first_coordinate;\n            temp_second_coord[0] = temp_second_coord[0] + 1;\n\n            while (temp_second_coord[0] <= second_coordinate[0]) {\n              if (!check_board(temp_second_coord)) {\n                alert(\"Please do not skip\");\n                fail_return(gamestateRef.current.player_turn);\n                return false;\n              }\n\n              temp_second_coord[0] = temp_second_coord[0] + 1;\n            }\n          }\n        } else if (first_coordinate[1] != second_coordinate[1]) {\n          alert(\"Please place all in vertical\");\n          fail_return(gamestateRef.current.player_turn);\n          return false;\n        }\n\n        first_coordinate = second_coordinate;\n\n        if (i + 1 != gamestateRef.current.just_added.length) {\n          second_coordinate = tile_coordinate(gamestateRef.current.just_added[i + 1]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function vertical_words(new_tile, up, down) {\n    let vertical_word_tile = [];\n    let prepend_up = false;\n\n    if (check_board(up)) {\n      prepend_up = true;\n      vertical_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n\n      while (check_board(up)) {\n        vertical_word_tile[vertical_word_tile.length - 1].unshift(boardstateRef.current.blocks[tile_index(up)]);\n        up[0] = up[0] - 1;\n      }\n    }\n\n    if (check_board(down)) {\n      if (prepend_up == false) {\n        vertical_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n      }\n\n      while (check_board(down)) {\n        vertical_word_tile[vertical_word_tile.length - 1].push(boardstateRef.current.blocks[tile_index(down)]);\n        down[0] = down[0] + 1;\n      }\n    }\n\n    return vertical_word_tile;\n  }\n\n  function horizontal_words(new_tile, left, right) {\n    let horizontal_word_tile = [];\n    let prepend_left = false;\n\n    if (check_board(left)) {\n      prepend_left = true;\n      horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n\n      while (check_board(left)) {\n        horizontal_word_tile[horizontal_word_tile.length - 1].unshift(boardstateRef.current.blocks[tile_index(left)]);\n        left[1] = left[1] - 1;\n      }\n    }\n\n    if (check_board(right)) {\n      if (prepend_left == false) {\n        horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]]);\n      }\n\n      while (check_board(right)) {\n        horizontal_word_tile[horizontal_word_tile.length - 1].push(boardstateRef.current.blocks[tile_index(right)]);\n        right[1] = right[1] + 1;\n      }\n    }\n\n    return horizontal_word_tile;\n  }\n\n  function words_block(new_tiles) {\n    let words = [];\n    let coor = tile_coordinate(gamestateRef.current.just_added[0]);\n    let up, down, left, right;\n    up = coor.slice(0);\n    down = coor.slice(0);\n    left = coor.slice(0);\n    right = coor.slice(0);\n    up[0] = up[0] - 1;\n    down[0] = down[0] + 1;\n    left[1] = left[1] - 1;\n    right[1] = right[1] + 1;\n\n    if (new_tiles.length == 1) {\n      horizontal_words(gamestateRef.current.just_added[0], left, right).forEach(horizontal_word => words.push(horizontal_word));\n      vertical_words(gamestateRef.current.just_added[0], up, down).forEach(vertical_word => words.push(vertical_word));\n    } else {\n      if (tile_coordinate(gamestateRef.current.just_added[0])[0] == tile_coordinate(gamestateRef.current.just_added[1])[0]) {\n        //horizontal\n        horizontal_words(gamestateRef.current.just_added[0], left, right).forEach(horizontal_word => words.push(horizontal_word));\n\n        for (let i = 0; i < new_tiles.length; i++) {\n          vertical_words(new_tiles[i], up, down).forEach(vertical_word => words.push(vertical_word));\n        }\n      } else {\n        //vertical\n        vertical_words(new_tiles[0], up, down).forEach(vertical_word => words.push(vertical_word));\n\n        for (let i = 0; i < new_tiles.length; i++) {\n          horizontal_words(new_tiles[i], left, right).forEach(horizontal_word => words.push(horizontal_word));\n        }\n      }\n    }\n\n    return words;\n  }\n\n  function new_block_score(new_block) {\n    let new_block_s = 0;\n    let double_word = 0;\n    let triple_word = 0;\n\n    if (new_block.type == \"dw\" || new_block.type == \"st\") {\n      new_block_s += new_block.content.score;\n      double_word += 1;\n    } else if (new_block.type == \"tw\") {\n      new_block_s += new_block.content.score;\n      triple_word += 1;\n    } else if (new_block.type == \"dl\") {\n      new_block_s += new_block.content.score * 2;\n    } else if (new_block.type == \"tl\") {\n      new_block_s += new_block.content.score * 3;\n    } else {\n      new_block_s += new_block.content.score;\n    }\n\n    console.log(\"INDIVIDUAL WORD SCORE\", [new_block_s, double_word, triple_word]);\n    return [new_block_s, double_word, triple_word];\n  }\n\n  function old_block_score(old_block) {\n    let old_tile_s = 0;\n    old_tile_s += old_block.content.score;\n    return old_tile_s;\n  }\n\n  function word_score(word_blocks) {\n    let individual_word_score = 0;\n    var double_word = 0;\n    var triple_word = 0;\n\n    for (let z = 0; z < word_blocks.length; z++) {\n      if (word_blocks[z].content.just_added == true) {\n        let scores = new_block_score(word_blocks[z]);\n        individual_word_score += scores[0];\n        double_word += scores[1];\n        triple_word += scores[2];\n      } else {\n        individual_word_score += old_block_score(word_blocks[z]);\n      }\n    }\n\n    if (double_word != 0) {\n      individual_word_score = individual_word_score * 2 * double_word;\n    }\n\n    if (triple_word != 0) {\n      individual_word_score = individual_word_score * 3 * triple_word;\n    }\n\n    return individual_word_score;\n  }\n\n  function additionalscore(words) {\n    let extra_score = 0;\n\n    for (let y = 0; y < words.length; y++) {\n      extra_score += word_score(words[y]);\n    }\n\n    if (gamestateRef.current.just_added.length == 7) {\n      extra_score += 50;\n    }\n\n    return extra_score;\n  }\n\n  function Score() {\n    if (check_validity()) {\n      let words = words_block(gamestateRef.current.just_added);\n      let updated_score = playerlistRef.current[gamestateRef.current.player_turn].score + additionalscore(words);\n      let sachet = { ...sachetstateRef.current\n      };\n      Object.setPrototypeOf(sachet, sachetstateRef.current);\n      let drawn_tiles = playerlistRef.current[gamestateRef.current.player_turn].draw(sachet);\n      setplayerlistState(prevplayerlistState => {\n        let newplayerlistState = [...prevplayerlistState];\n        newplayerlistState[gamestateRef.current.player_turn].score = updated_score;\n        newplayerlistState[gamestateRef.current.player_turn].tiles = newplayerlistState[gamestateRef.current.player_turn].tiles.concat(drawn_tiles);\n        return newplayerlistState;\n      });\n      values.next_funct();\n\n      for (let i = 0; i < drawn_tiles.length; i++) {\n        drawn_tiles[i].canDrop = false;\n        drawn_tiles[i].canDrag = false;\n      }\n\n      gamestateRef.current.socket.current.emit(\"emit_updated_score\", {\n        room_id: gamestateRef.current.room_id,\n        score: updated_score,\n        drawn_tiles: drawn_tiles\n      });\n    }\n  }\n\n  useEffect(() => {\n    gamestateRef.current.socket.current.on(\"update_player_score\", socket_out => {\n      let sachet2 = { ...sachetstateRef.current\n      };\n      Object.setPrototypeOf(sachet2, sachetstateRef.current);\n      sachet2.remove_by_tiles(socket_out.drawn_tiles);\n      setplayerlistState(prevplayerlistState => {\n        let newplayerlistState = [...prevplayerlistState];\n        newplayerlistState[gamestateRef.current.player_turn].score = socket_out.updated_score;\n        newplayerlistState[gamestateRef.current.player_turn].draw_by_tiles(socket_out.drawn_tiles);\n        return newplayerlistState;\n      });\n      values.next_func(sachet2);\n    });\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"button\", {\n      type: \"button\",\n      className: \"score_button\",\n      onClick: Score,\n      disabled: !scoreActive,\n      children: \"Score\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 387,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 386,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Score_button, \"ZR+1zwFySDp64RTzcqmj/wVo4kM=\");\n\n_c = Score_button;\nexport default Score_button;\n\nvar _c;\n\n$RefreshReg$(_c, \"Score_button\");","map":{"version":3,"sources":["C:/Users/TzeHaoTay/Desktop/CS/scrabble2/frontend/src/Games_page/Action/Score_button.js"],"names":["React","useState","useContext","useEffect","useRef","UserContext","GamesContext","BlocksContext","PlayerListContext","AnalyticsDataContext","SachetContext","sachet","analytics_data","games_sachet","Score_button","values","profile","setprofile","playerlistState","setplayerlistState","gameState","setgameState","boardState","setboardState","analyticsdataState","setanalyticsdataState","sachetState","setsachetState","playerlistRef","gamestateRef","boardstateRef","sachetstateRef","current","scoreActive","setscoreActive","player_turn","your_index","delete_list","length","fail_return","return_tiles","i","just_added","push","blocks","content","placed","canDrop","container_index","tiles","socket","emit","room_id","prevplayerlistState","newplayerlistState","concat","prevboardState","newboardState","forEach","index","prevgameState","tile_coordinate","row","Math","floor","column_length","column","tile_index","coordinate","check_board","row_length","check_validity","turn_num","start_block","find","block","type","alert","attached","coor","up","down","left","right","first_coordinate","second_coordinate","direction","temp_second_coord","vertical_words","new_tile","vertical_word_tile","prepend_up","unshift","horizontal_words","horizontal_word_tile","prepend_left","words_block","new_tiles","words","slice","horizontal_word","vertical_word","new_block_score","new_block","new_block_s","double_word","triple_word","score","console","log","old_block_score","old_block","old_tile_s","word_score","word_blocks","individual_word_score","z","scores","additionalscore","extra_score","y","Score","updated_score","Object","setPrototypeOf","drawn_tiles","draw","next_funct","canDrag","on","socket_out","sachet2","remove_by_tiles","draw_by_tiles","next_func"],"mappings":"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","sourcesContent":["import React, {useState,useContext,useEffect,useRef} from 'react';\r\nimport {UserContext} from '../../UserContext.js'\r\nimport {GamesContext,BlocksContext,PlayerListContext,AnalyticsDataContext,SachetContext} from '../GamesContext.js'\r\nimport sachet, { analytics_data } from '../Sachet.js';\r\nimport {games_sachet} from '../Gamespage.js'\r\nimport './Actionbar.css'\r\n\r\nfunction Score_button(values){\r\n  const {profile,setprofile}=useContext(UserContext)\r\n  const {playerlistState,setplayerlistState}=useContext(PlayerListContext)\r\n  const {gameState,setgameState}=useContext(GamesContext)   \r\n  const {boardState,setboardState}=useContext(BlocksContext)\r\n  const {analyticsdataState,setanalyticsdataState}=useContext(AnalyticsDataContext)\r\n  const {sachetState,setsachetState}=useContext(SachetContext)   \r\n  const playerlistRef=useRef(null);\r\n  const gamestateRef=useRef(null);\r\n  const boardstateRef=useRef(null);\r\n  const sachetstateRef=useRef(null);\r\n  playerlistRef.current=playerlistState\r\n  gamestateRef.current=gameState\r\n  boardstateRef.current=boardState\r\n  sachetstateRef.current=sachetState\r\n    const [scoreActive,setscoreActive]=useState(false)\r\n    useEffect(()=>{ \r\n        if(gameState.player_turn==gameState.your_index && !playerlistState[gameState.your_index].delete_list.length){\r\n          setscoreActive(true)\r\n        }else{\r\n          setscoreActive(false)\r\n        }\r\n      },[gamestateRef.current.player_turn,playerlistRef.current[gamestateRef.current.your_index].delete_list])\r\n    \r\n    function fail_return(player_turn){\r\n      let return_tiles=[]\r\n      for (let i=0;i<gamestateRef.current.just_added.length;i++){\r\n        return_tiles.push(boardstateRef.current.blocks[gamestateRef.current.just_added[i]].content)\r\n        return_tiles[i].just_added=false\r\n        return_tiles[i].placed=false\r\n        return_tiles[i].canDrop=true\r\n        return_tiles[i].container_index=playerlistRef.current[player_turn].tiles.length+i\r\n      }\r\n      gamestateRef.current.socket.current.emit(\"emit_fail_return\",{\r\n        return_tiles:return_tiles,\r\n        room_id:gamestateRef.current.room_id,\r\n        just_added:gamestateRef.current.just_added})\r\n\r\n      setplayerlistState((prevplayerlistState=>{\r\n        let newplayerlistState=[...prevplayerlistState]\r\n        newplayerlistState[player_turn].tiles=newplayerlistState[player_turn].tiles.concat(return_tiles)\r\n        return newplayerlistState\r\n      }))\r\n      setboardState((prevboardState=>{\r\n        let newboardState={...prevboardState}\r\n        gamestateRef.current.just_added.forEach(index=>{\r\n          newboardState.blocks[index].content=null\r\n        })\r\n        return newboardState\r\n      }))\r\n      setgameState((prevgameState=>({...prevgameState,\r\n        just_added:[]     \r\n    }))) \r\n    }\r\n    function tile_coordinate(index){\r\n      let row = Math.floor(index / boardstateRef.current.column_length)\r\n      let column=index%boardstateRef.current.column_length\r\n      return [row,column]\r\n    }\r\n    function tile_index(coordinate){\r\n      return coordinate[0]*boardstateRef.current.column_length+coordinate[1];\r\n    }\r\n    function check_board(coordinate){\r\n      if (coordinate[0]<0 || coordinate[0]>=boardstateRef.current.row_length || coordinate[1]<0 || coordinate[1]>=boardstateRef.current.column_length){\r\n        return false\r\n    }\r\n      let index=tile_index(coordinate)\r\n      if(boardstateRef.current.blocks[index].content){\r\n        if(boardstateRef.current.blocks[index].content.placed){return true}\r\n      }\r\n      return false\r\n\r\n    }\r\n\r\n    function check_validity(){\r\n      if (gamestateRef.current.turn_num==0){\r\n        let start_block=boardstateRef.current.blocks.find(block=>block.type==\"st\")\r\n        if(!start_block.content){\r\n          alert(\"Please place the tile on the start block.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false\r\n        }\r\n      }else{\r\n        let attached=false;\r\n        for(let i=0;i<gamestateRef.current.just_added.length;i++){\r\n          let coor=tile_coordinate(gamestateRef.current.just_added[i])\r\n          let up,down,left,right;\r\n          up=down=left=right=coor;\r\n\r\n          up[0]=up[0]-1;\r\n          down[0]=down[0]+1;\r\n          left[1]=left[1]-1;\r\n          right[1]=right[1]+1;\r\n\r\n            if (check_board(up)||check_board(down)||check_board(left)||check_board(right)){\r\n                attached=true;\r\n                break;\r\n            }    \r\n        }\r\n        if (attached==false){\r\n          alert (\"Please place your tiles adjacent to an existing tile.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false;\r\n        }\r\n      }\r\n      if(gamestateRef.current.just_added.length>1){\r\n        let first_coordinate=tile_coordinate(gamestateRef.current.just_added[0]);\r\n        let second_coordinate=tile_coordinate(gamestateRef.current.just_added[1]);\r\n\r\n        if (first_coordinate[0]==second_coordinate[0] ){\r\n          var direction =\"horizontal\";\r\n      } else if (first_coordinate[1]==second_coordinate[1]){\r\n          var direction =\"vertical\";\r\n      } else {\r\n          alert (\"Your sequence of tiles must either be in horizontal or vertical form, adjacent to each other.\")\r\n          fail_return(gamestateRef.current.player_turn)\r\n          return false;\r\n      }\r\n      for (let i =1 ; i<gamestateRef.current.just_added;i++){\r\n        if (direction==\"horizontal\"){\r\n             if ((first_coordinate[1]+1)!=second_coordinate[1] && first_coordinate[0]==second_coordinate[0]){\r\n                \r\n                let temp_second_coord=first_coordinate;\r\n                temp_second_coord[1]=temp_second_coord[1]+1;\r\n                while(temp_second_coord[1]<=second_coordinate[1]){\r\n                    if (!check_board(temp_second_coord)){\r\n                        alert(\"Please do not skip\");\r\n                        fail_return(gamestateRef.current.player_turn)\r\n                        return false;\r\n                        }\r\n                    temp_second_coord[1]=temp_second_coord[1]+1;\r\n                    }\r\n                    \r\n                }\r\n\r\n             else if(first_coordinate[0]!=second_coordinate[0]){\r\n                alert(\"Please place all in horizontal\")\r\n                fail_return(gamestateRef.current.player_turn)\r\n                return false;\r\n            } \r\n        } else if (direction==\"vertical\"){\r\n            if((first_coordinate[0]+1)!=second_coordinate[0] && first_coordinate[1]==second_coordinate[1]){\r\n                \r\n                let temp_second_coord=first_coordinate;\r\n                temp_second_coord[0]=temp_second_coord[0]+1;\r\n                while(temp_second_coord[0]<=second_coordinate[0]){\r\n                    if (!check_board(temp_second_coord)){\r\n                        alert(\"Please do not skip\");\r\n                        fail_return(gamestateRef.current.player_turn)\r\n                        return false;\r\n                        }\r\n                    temp_second_coord[0]=temp_second_coord[0]+1;\r\n                    }\r\n                    \r\n                }\r\n            } else if ((first_coordinate[1])!=second_coordinate[1]){\r\n                alert(\"Please place all in vertical\")\r\n                fail_return(gamestateRef.current.player_turn)\r\n                return false;\r\n            }\r\n        \r\n        \r\n        first_coordinate=second_coordinate;\r\n        if ((i+1)!=gamestateRef.current.just_added.length){\r\n            second_coordinate=tile_coordinate(gamestateRef.current.just_added[i+1])\r\n            }\r\n        }\r\n      }\r\n      return true\r\n    }\r\n\r\n    function vertical_words(new_tile,up,down){\r\n\r\n      let vertical_word_tile=[];\r\n      let prepend_up=false;\r\n  \r\n      if (check_board(up)){\r\n          prepend_up=true\r\n          vertical_word_tile.push([boardstateRef.current.blocks[new_tile]])\r\n              while(check_board(up)){\r\n                  vertical_word_tile[vertical_word_tile.length-1].unshift(boardstateRef.current.blocks[tile_index(up)])\r\n                  up[0]=up[0]-1;\r\n          }\r\n          \r\n      } \r\n      if (check_board(down)){\r\n          if (prepend_up==false){\r\n              vertical_word_tile.push([boardstateRef.current.blocks[new_tile]])}\r\n  \r\n          while(check_board(down)){\r\n              vertical_word_tile[vertical_word_tile.length-1].push(boardstateRef.current.blocks[tile_index(down)])\r\n              down[0]=down[0]+1;\r\n          }\r\n      }\r\n      return vertical_word_tile\r\n  }\r\n  function horizontal_words(new_tile,left,right){\r\n  \r\n      let horizontal_word_tile=[];\r\n      let prepend_left=false;\r\n      \r\n      if (check_board(left)) {\r\n          prepend_left=true\r\n          horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]])\r\n          while(check_board(left)){\r\n              horizontal_word_tile[horizontal_word_tile.length-1].unshift(boardstateRef.current.blocks[tile_index(left)])\r\n              left[1]=left[1]-1;\r\n              }\r\n          }\r\n          \r\n      if (check_board(right)){\r\n  \r\n          if (prepend_left==false){\r\n          horizontal_word_tile.push([boardstateRef.current.blocks[new_tile]])}\r\n  \r\n          while(check_board(right)){\r\n              horizontal_word_tile[horizontal_word_tile.length-1].push(boardstateRef.current.blocks[tile_index(right)])\r\n              right[1]=right[1]+1;\r\n              }\r\n          }\r\n      return horizontal_word_tile\r\n          \r\n      }\r\n\r\n    function words_block(new_tiles){\r\n      let words=[];\r\n  \r\n      let coor=tile_coordinate(gamestateRef.current.just_added[0])\r\n      let up,down,left,right\r\n      up=coor.slice(0);\r\n      down=coor.slice(0);\r\n      left=coor.slice(0);\r\n      right=coor.slice(0);\r\n  \r\n      up[0]=up[0]-1;\r\n      down[0]=down[0]+1;\r\n      left[1]=left[1]-1;\r\n      right[1]=right[1]+1;\r\n      \r\n      if(new_tiles.length==1){      \r\n  \r\n          horizontal_words(gamestateRef.current.just_added[0],left,right).forEach(horizontal_word=>words.push(horizontal_word));\r\n          vertical_words(gamestateRef.current.just_added[0],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n          \r\n      }else{\r\n       \r\n          if (tile_coordinate(gamestateRef.current.just_added[0])[0]==tile_coordinate(gamestateRef.current.just_added[1])[0]){\r\n              //horizontal\r\n              horizontal_words(gamestateRef.current.just_added[0],left,right).forEach(horizontal_word=>words.push(horizontal_word));\r\n              for (let i =0 ; i<new_tiles.length;i++){\r\n                  \r\n                  vertical_words(new_tiles[i],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n          \r\n              }\r\n          }else{\r\n              //vertical\r\n              vertical_words(new_tiles[0],up,down).forEach(vertical_word=>words.push(vertical_word));\r\n              for (let i =0 ; i<new_tiles.length;i++){\r\n                  horizontal_words(new_tiles[i],left,right).forEach(horizontal_word=>words.push(horizontal_word));       \r\n              }\r\n          } \r\n          }\r\n  \r\n      return words\r\n  }\r\n\r\n  function new_block_score(new_block){\r\n    let new_block_s=0\r\n    let double_word=0;\r\n    let triple_word=0;\r\n    \r\n    if (new_block.type==\"dw\" || new_block.type==\"st\"){\r\n        new_block_s += new_block.content.score;\r\n        double_word += 1;\r\n    } else if (new_block.type==\"tw\"){\r\n        new_block_s += new_block.content.score;\r\n        triple_word += 1;\r\n    } else if (new_block.type==\"dl\"){\r\n        new_block_s += new_block.content.score*2\r\n    } else if (new_block.type==\"tl\"){\r\n        new_block_s += new_block.content.score*3\r\n    }else{\r\n        new_block_s += new_block.content.score\r\n    }\r\n    console.log(\"INDIVIDUAL WORD SCORE\",[new_block_s,double_word,triple_word])\r\n    return [new_block_s,double_word,triple_word]\r\n}\r\nfunction old_block_score(old_block){  \r\n    let old_tile_s=0;\r\n    old_tile_s += old_block.content.score\r\n    return old_tile_s\r\n\r\n}\r\n\r\nfunction word_score(word_blocks){\r\n\r\n    let individual_word_score=0;\r\n    var double_word=0;\r\n    var triple_word=0;\r\n  \r\n    for (let z=0; z<word_blocks.length; z++){\r\n\r\n        if (word_blocks[z].content.just_added==true){\r\n            let scores=new_block_score(word_blocks[z])\r\n            individual_word_score+=scores[0];\r\n            double_word+=scores[1];\r\n            triple_word+=scores[2]\r\n        } else{\r\n            individual_word_score+=old_block_score(word_blocks[z]);\r\n        }}\r\n    \r\n    if (double_word!=0){\r\n        individual_word_score = individual_word_score * 2 * double_word;\r\n    }\r\n\r\n    if (triple_word!=0){\r\n        individual_word_score = individual_word_score * 3 * triple_word;\r\n    }\r\n\r\n    \r\n    return individual_word_score \r\n}\r\n\r\n  function additionalscore(words){\r\n  \r\n    let extra_score=0; \r\n    \r\n    for (let y=0;y<words.length;y++){\r\n        extra_score+=word_score(words[y])\r\n    }\r\n\r\n    if (gamestateRef.current.just_added.length==7){\r\n        extra_score+=50;\r\n    }  \r\n    return extra_score\r\n}\r\n\r\n    function Score(){\r\n      \r\n      if(check_validity()){\r\n          let words=words_block(gamestateRef.current.just_added)\r\n          let updated_score=playerlistRef.current[gamestateRef.current.player_turn].score+additionalscore(words);\r\n          let sachet={...sachetstateRef.current}\r\n          Object.setPrototypeOf( sachet,sachetstateRef.current )\r\n          let drawn_tiles=playerlistRef.current[gamestateRef.current.player_turn].draw(sachet)          \r\n          setplayerlistState(prevplayerlistState=>{\r\n            let newplayerlistState=[...prevplayerlistState]\r\n            newplayerlistState[gamestateRef.current.player_turn].score=updated_score\r\n            newplayerlistState[gamestateRef.current.player_turn].tiles=newplayerlistState[gamestateRef.current.player_turn].tiles.concat(drawn_tiles);\r\n            return newplayerlistState\r\n          })\r\n          values.next_funct()\r\n          for (let i=0;i<drawn_tiles.length;i++){\r\n            drawn_tiles[i].canDrop=false\r\n            drawn_tiles[i].canDrag=false\r\n          }\r\n          gamestateRef.current.socket.current.emit(\"emit_updated_score\",{\r\n            room_id:gamestateRef.current.room_id,\r\n            score:updated_score,\r\n            drawn_tiles:drawn_tiles})\r\n      }\r\n\r\n    }\r\n    useEffect(()=>{\r\n      gamestateRef.current.socket.current.on(\"update_player_score\",(socket_out)=>{\r\n        let sachet2={...sachetstateRef.current}\r\n        Object.setPrototypeOf( sachet2,sachetstateRef.current )\r\n        sachet2.remove_by_tiles(socket_out.drawn_tiles)\r\n        setplayerlistState(prevplayerlistState=>{\r\n          let newplayerlistState=[...prevplayerlistState]\r\n          newplayerlistState[gamestateRef.current.player_turn].score=socket_out.updated_score\r\n          newplayerlistState[gamestateRef.current.player_turn].draw_by_tiles(socket_out.drawn_tiles)\r\n          return newplayerlistState\r\n        })\r\n        values.next_func(sachet2)\r\n      })\r\n    },[])\r\n    return(\r\n        <div>\r\n            <button type=\"button\" className=\"score_button\" onClick={Score} disabled={!scoreActive}>Score</button> \r\n        </div>)\r\n}\r\n\r\nexport default Score_button"]},"metadata":{},"sourceType":"module"}